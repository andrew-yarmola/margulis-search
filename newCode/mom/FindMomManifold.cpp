/*
 *  FindMomManifold.cpp
 *  mom
 *
 *  Created by Nathaniel Thurston on 17/10/2008.
 *  Copyright 2008 __MyCompanyName__. All rights reserved.
 *
 */

#include "FindMomManifold.h"
#include <vector>
#include <map>
#include <list>

using namespace std;

namespace FindMomManifoldImpl {
	// A potential mom is generated by pairs of words in the group.
	// To "dehydrate" the mom, each pair (a,b) generates the hexagon:
	//	a = b - b^-1 = b^-1 a - a^-1 b = a^-1 -
	// where the '=' links are edges along the cusp torus,
	// and the '-' links are edges along one of the 1-handles
	
	// In order for a potential mom to be a mom, some identification
	// of vertices is necessary.  We use CanonicalName to "simplify" words
	// according to the provided relator, to prove that certain vertices are
	// identical.
	struct PotentialMom {
		vector< pair< string, string > > hexagons;
	};
	
	// A dehyrated mom is "expanded" relative to a given relator.
	// We keep track of the expanded combinatorical information about
	// each hexagon included in the mom.
	struct Vertex {
		// the canonical name of the vertex
		string name;
		
		 // the canonical name of the class of the vertex
		 // modulo the cusp translation lattice
		string nameClass;
	};
	struct Hexagon {
		// vertices are arranged so that v[i] is connected to v[i+1 % 6]
		// For the even-odd pairs v[2i] - v[2i+1], the edge is on the cusp torus
		// For the odd-even pairs v[2i+1] - v[2i+2 % 6], the edge is on a 1-handle,
		// so that v[2i+1] = inverse(v[2i+2 % 6])
		Vertex v[6];
	};
	
	struct Mom {
		vector<Hexagon> hexagons;
		map<string, int> valence;
	};
	
	struct FaceCoordinates {
		FaceCoordinates() :hemisphere(-1), dipyramid(-1), tetrahedron(-1) {};
		int hemisphere;
		int dipyramid;
		int tetrahedron;
	};
		
	struct Face {
		Hexagon *hexagon;
		int vertexIndex;
		
		AComplex1Jet bridge;
		double bridgeAngleAtCenter;
		
		Face* partner; // the corresponding face on the other half of the dipyramid
		Face* gluing; // the face to which this face is glued
		
		FaceCoordinates coords;
	};
	
	struct FaceAngleOrder : public binary_function<Face*, Face*, bool> {
		bool operator() (const Face* a, const Face* b)
		{
			return a->bridgeAngleAtCenter < b->bridgeAngleAtCenter;
		}
	};
	
	struct OneHandle {
		int valence;
		string hemisphereName[2];
		list<Face*> hemisphere[2];
	};
	
	struct HandleValenceOrder : public binary_function<OneHandle, OneHandle, bool> {
		bool operator() (const OneHandle& a, const OneHandle& b)
		{
			return a.valence < b.valence;
		}
	};
	
	struct Impl : public FindMomManifold {
		Impl(Environment *env_);
		bool find(Params<AComplex1Jet>& params, string relator);
	private:
		typedef map< string, vector< Mom > > FoundMoms;
		
		FoundMoms::iterator dehydrate(string relator);
		
		Environment *env;
		vector<PotentialMom> moms;
		FoundMoms foundMoms;
	};
	
	GL2ACJ evaluate(string word, Params<AComplex1Jet>& params)
	{
		AComplex1Jet one(1), zero(0);
		GL2ACJ w(one, zero, zero, one);
		GL2ACJ G(constructG(params));
		GL2ACJ g(~G);
		
		string::size_type pos;
		int x = 0;
		int y = 0;
		for (pos = 0; pos <= word.length(); ++pos) {
			int c = pos < word.length() ? word[pos] : -1;
			switch(c) {
				case 'm': --x; break;
				case 'M': ++x; break;
				case 'n': --y; break;
				case 'N': ++y; break;
				default: {
					if (x != 0 || y != 0) {
						w = w*constructT(params, x, y);
						x=y=0;
					}
					if (c == 'g')
						w = w*g;
					else if (c == 'G')
						w = w*G;
				}
			}
		}
		return w;
	}

	void printMom(Mom& mom)
	{
		for (int j = 0; j < mom.hexagons.size(); ++j) {
			Hexagon& h = mom.hexagons[j];
			fprintf(stderr, "\tHEXAGON: %s = %s - %s = %s - %s = %s -\n",
				h.v[0].name.c_str(),
				h.v[1].name.c_str(),
				h.v[2].name.c_str(),
				h.v[3].name.c_str(),
				h.v[4].name.c_str(),
				h.v[5].name.c_str()
			);
		}
		for (map<string, int>::iterator it = mom.valence.begin(); it != mom.valence.end(); ++it) {
			fprintf(stderr, "\tVERTEX: %s %d\n", it->first.c_str(), it->second);
		}
	}
	
	Impl::Impl(Environment *env_) :env(env_)
	{
		char buf[1000];
		PotentialMom currentMom;
		while (fgets(buf, sizeof(buf), env->momsFP)) {
			int n = strlen(buf);
			if (buf[n-1] == '\n') buf[n-1] = '\0';
			char* pos = index(buf, ' ');
			if (pos) {
				*pos++ = '\0';
				currentMom.hexagons.push_back(make_pair(string(buf), string(pos)));
			} else {
				if (!currentMom.hexagons.empty()) {
					moms.push_back(currentMom);
					currentMom.hexagons.clear();
				}
			}
		}
		if (!currentMom.hexagons.empty())
			moms.push_back(currentMom);
		
		int TODO_load_gluings;
	}
	
	Impl::FoundMoms::iterator Impl::dehydrate(string relator)
	{
		vector<Mom> found;
		CanonicalName cn;
		cn.addRelator(relator);
		vector<PotentialMom>::iterator itM;
		for (itM = moms.begin(); itM != moms.end(); ++itM) {
			Mom mom;
			vector< pair< string, string > >::iterator itT;
			for (itT = itM->hexagons.begin(); itT != itM->hexagons.end(); ++itT) {
				Hexagon h;
				h.v[0].name = cn.getCanonicalName(itT->first);
				h.v[1].name = cn.getCanonicalName(itT->second);
				h.v[2].name = cn.getCanonicalName(cn.inverse(itT->second));
				h.v[3].name = cn.getCanonicalName(cn.inverse(itT->second) + itT->first);
				h.v[4].name = cn.getCanonicalName(cn.inverse(itT->first) + itT->second);
				h.v[5].name = cn.getCanonicalName(cn.inverse(itT->first));
				
				for (int i = 0; i < 6; ++i) {
					h.v[i].nameClass = cn.getCanonicalClass(h.v[i].name);
					++mom.valence[h.v[i].nameClass];
				}
				mom.hexagons.push_back(h);
			}
//			printMom(mom);
			if (mom.valence.size() == 2 * itM->hexagons.size()) {
//				fprintf(stderr, "added %d\n", mom.valence.size());
				found.push_back(mom);
			} else {
//				fprintf(stderr, "non added %d %d\n",
//					mom.valence.size(), itM->hexagons.size());
			}
		}
		return foundMoms.insert(make_pair(relator, found)).first;
	}
	
	bool Impl::find(Params<AComplex1Jet>& params, string relator)
	{
		FoundMoms::iterator itFound = foundMoms.find(relator);
		if (itFound == foundMoms.end()) {
			itFound = dehydrate(relator);
		}
		double bestMaxE = 100;
		for (int i = 0; i < itFound->second.size(); ++i) {
			Mom& mom = itFound->second[i];

//			printMom(mom);
			list<Face> allFaces;
			list<OneHandle> allOneHandles;
			map<string, OneHandle*> handleMap;
			
			// Initialize the Handles and Faces
			for (int j = 0; j < mom.hexagons.size(); ++j) {
				Hexagon& hexagon = mom.hexagons[j];
				// Create the faces.
				Face* faces[6];
				for (int k = 0; k < 6; ++k) {
					allFaces.push_back(Face());
					faces[k] = &allFaces.back();
					faces[k]->hexagon = &hexagon;
					faces[k]->vertexIndex = k;
				}
				
				for (int k = 0; k < 6; k += 2) {
					faces[k]->partner = faces[(k+5)%6];
					faces[(k+5)%6]->partner = faces[k];
					faces[k]->gluing = faces[k+1];
					faces[k+1]->gluing = faces[k];
					
					GL2ACJ m0 = evaluate(hexagon.v[k].name, params);
					GL2ACJ m1 = evaluate(hexagon.v[k+1].name, params);
					AComplex1Jet difference = m0.a / m0.c - m1.a / m1.c;
					faces[k]->bridge = difference;
					faces[k+1]->bridge = -difference;
				}
				for (int k = 0; k < 6; ++k) {
					faces[k]->bridgeAngleAtCenter = atan2(
						faces[k]->bridge.center().real(),
						faces[k]->bridge.center().imag()
					);
				}
				
				// Add the faces to the handles, creating handes as needed
				for (int k = 1; k < 6; k += 2) {
					Vertex& v0 = hexagon.v[k];
					Vertex& v1 = hexagon.v[(k+1)%6];
					OneHandle*& handle = handleMap[v0.nameClass];
					if (handle == 0) {
						allOneHandles.push_back(OneHandle());
						handle = &allOneHandles.back();
						handleMap[v1.nameClass] = handle;
						handle->hemisphereName[0] = v0.nameClass;
						handle->hemisphereName[1] = v1.nameClass;
					}
					if (handle->hemisphereName[0] == v0.nameClass) {
						handle->hemisphere[0].push_back(faces[k]);
						handle->hemisphere[1].push_back(faces[(k+1)%6]);
					} else {
						handle->hemisphere[1].push_back(faces[k]);
						handle->hemisphere[0].push_back(faces[(k+1)%6]);
					}
				}
			}
			
			bool embeddednessGuaranteed = true;
			double maximumE = 1;
			GL2ACJ mg = evaluate("g", params);
			list<OneHandle>::iterator  itH;
			for (itH = allOneHandles.begin(); itH != allOneHandles.end(); ++itH) {
				GL2ACJ m0 = evaluate(itH->hemisphereName[0], params);
				GL2ACJ m1 = evaluate(itH->hemisphereName[1], params);
				double e0 = maxabs(m0.c / mg.c);
				double e1 = maxabs(m1.c / mg.c);
				if (e0 > 1.5152 && e1 > 1.5152)
					embeddednessGuaranteed = false;
				if (maximumE < min(e0, e1))
					maximumE = min(e0, e1);
				printf("e(%s,%s) = (%f,%f)\n",
					itH->hemisphereName[0].c_str(), itH->hemisphereName[1].c_str(),
					e0, e1);
			}
			
			// Collapse and remove any handles which have valence 2
			bool hasValenceOne = false;
			for (itH = allOneHandles.begin(); itH != allOneHandles.end(); ) {
				itH->valence = itH->hemisphere[0].size();
				assert(itH->valence == itH->hemisphere[1].size());
				if (itH->valence == 1)
					hasValenceOne = true;
				if (itH->valence == 2) {
					for (int j = 0; j < 2; ++j) {
						Face* f0 = itH->hemisphere[j].front();
						Face* f1 = itH->hemisphere[j].back();
						double theta = f0->bridgeAngleAtCenter - f1->bridgeAngleAtCenter;
						theta = fmod(theta + 2*M_PI, 2*M_PI);
						if (theta > M_PI)
							theta = 2*M_PI - theta;
						fprintf(stderr, "angle difference for %s[%d] = %f\n",
							itH->hemisphereName[j].c_str(), j, theta);
						f0->gluing->gluing = f1->gluing;
						f1->gluing->gluing = f0->gluing;
					}
					itH = allOneHandles.erase(itH);
				} else {
					++itH;
				}
			}
			if (hasValenceOne)
				continue;
			
			// Sort the faces on the handles of valence > 2 in order around the island,
			// and check to make sure that the sort order doesn't change within the box
			
			bool orderGuaranteed = true;
			for (itH = allOneHandles.begin(); itH != allOneHandles.end(); ++itH) {
				for (int j = 0; j < 2; ++j) {
					list<Face*>& hemisphere = itH->hemisphere[j];
					hemisphere.sort(FaceAngleOrder());
					
					// Find a "canonical" edge to appear first, and choose
					// the cyclic re-ordering which puts that canonical edge first
					list<Face*>::iterator itFirst;
					Vertex firstVertex;
					list<Face*>::iterator itF;
					for (itF = hemisphere.begin(); itF != hemisphere.end(); ++itF) {
						Face& f = **itF;
						Vertex v = f.hexagon->v[f.vertexIndex ^ 0x1];
						if (firstVertex.nameClass.empty()
						 || v.nameClass < firstVertex.nameClass
						 || v.nameClass == firstVertex.nameClass && v.name < firstVertex.name) {
							firstVertex = v;
							itFirst = itF;
						}
					}
					if (itFirst != hemisphere.begin())
						hemisphere.splice(hemisphere.begin(), hemisphere, itFirst, hemisphere.end());
					
					// Finally, check to see if the vertex order can change.
					// I'm not completely sure about this, but the check is to
					// see if the angle can be 0 (by bounding the ratio away
					// from the positive real axis), and I *think* this is enough
					list<Face*>::iterator itFPrev = --hemisphere.end();
					for (itF = hemisphere.begin(); itF != hemisphere.end(); ++itF) {
						AComplex1Jet div = (*itF)->bridge / (*itFPrev)->bridge;
						double size = div.size() + div.error();
						if (fabs(div.center().imag()) <= size && div.center().real() > -size)
							orderGuaranteed = false;
						itFPrev = itF;
					}
				}
			}
			
			// Assign coordinates to each face
			allOneHandles.sort(HandleValenceOrder());
			int dipyramidIndex = 0;
			for (itH = allOneHandles.begin(); itH != allOneHandles.end(); ++itH) {
				list<Face*>& hemisphere = itH->hemisphere[0];
				list<Face*>::iterator itF;
				int k = 0;
				for (itF = hemisphere.begin(); itF != hemisphere.end(); ++itF) {
					Face& f = **itF;
					f.coords.hemisphere = 0;
					f.coords.dipyramid = dipyramidIndex;
					f.coords.tetrahedron = k;
					
					f.partner->coords.hemisphere = 1;
					f.partner->coords.dipyramid = dipyramidIndex;
					f.partner->coords.tetrahedron = k;
					++k;
				}
				dipyramidIndex += itH->valence;
			}
			
			// As a sanity check, make sure that the faces of the [1] hemisphere
			// are in inverse order
			bool orderPreserved = true;
			for (itH = allOneHandles.begin(); itH != allOneHandles.end(); ++itH) {
				list<Face*>& hemisphere = itH->hemisphere[1];
				int k = hemisphere.back()->coords.tetrahedron;
				list<Face*>::iterator itF;
				for (itF = hemisphere.begin(); itF != hemisphere.end(); ++itF) {
					int diff = (*itF)->coords.tetrahedron - k;
					diff = (diff + itH->valence) % itH->valence;
					if (diff != itH->valence - 1)
						orderPreserved = false;
					k = (*itF)->coords.tetrahedron;
				}
			}
			if (!orderPreserved)
				continue;
			
			// generate the gluing string for peter's triangulation-construction code
			vector<int> gluings(2*dipyramidIndex, -1);
			for (itH = allOneHandles.begin(); itH != allOneHandles.end(); ++itH) {
				for (int j = 0; j < 2; ++j) {
					list<Face*>& hemisphere = itH->hemisphere[j];
					list<Face*>::iterator itF;
					for (itF = hemisphere.begin(); itF != hemisphere.end(); ++itF) {
						Face& f = **itF;
						Face& g = *f.gluing;
						int fi = f.coords.tetrahedron + f.coords.dipyramid + dipyramidIndex*f.coords.hemisphere;
						int gi = g.coords.tetrahedron + g.coords.dipyramid + dipyramidIndex*g.coords.hemisphere;
						gluings[fi] = gi;
					}
				}
			}
			
			string gluingString = "(";
			char buf[20];
			for (itH = allOneHandles.begin(); itH != allOneHandles.end(); ++itH) {
				sprintf(buf, "%d", itH->valence);
				gluingString += buf;
			}
			gluingString += "):";
			for (int j = 0; j < gluings.size(); ++j) {
				sprintf(buf, " %d", gluings[j]);
				gluingString += buf;
			}
			
			fprintf(stderr, "MOM-%d for %s: (%s, %s) maxE=%f\n", mom.hexagons.size(), relator.c_str(),
				orderGuaranteed ? "ordered" : "unordered",
				embeddednessGuaranteed ? "embedded" : "small balls", maximumE);
			fprintf(stderr, "GLUINGS(%s): %s\n",
				orderGuaranteed && embeddednessGuaranteed ? "OK" : "", gluingString.c_str());
			printMom(mom);

			if (maximumE < bestMaxE) bestMaxE = maximumE;
			if ( embeddednessGuaranteed && orderGuaranteed)
				return true;
		}
		if (bestMaxE < 100)
			fprintf(stderr, "best maximum E = %f\n", bestMaxE); 
		return false;
	}
};

FindMomManifold* FindMomManifold::create(Environment *env)
{
	return new FindMomManifoldImpl::Impl(env);
}
